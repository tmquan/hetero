#include "shrink.hpp"#include <cuComplex.h>#include "utility.hpp"#include "helper_math.h"namespace csmri{////////////////////////////////////////////////////////////////////////////////////////////////////#ifndef blockDimx#define blockDimx 16		#endif#ifndef blockDimy#define blockDimy 16		#endif#ifndef blockDimz#define blockDimz 1		#endif////////////////////////////////////////////////////////////////////////////////////////////////////__global__void __shrink1(	float2* src,	float2* dst,	int dimx,			int dimy,			int dimz,	float Lambda){	//3D global index	int3 idx = make_int3(		blockIdx.x*blockDim.x+threadIdx.x,		blockIdx.y*blockDim.y+threadIdx.y,		blockIdx.z*blockDim.z+threadIdx.z);		//1D global index	int index 	= 	idx.z*dimy*dimx						+	idx.y*dimx								+	idx.x;													  	//Check valid indices	if (idx.x >= dimx || idx.y >= dimy || idx.z >= dimz)		return;		//Do computing	float2 t 	= src[index];	float s  	= sqrtf(t.x*t.x + t.y*t.y);		float ss = s - Lambda;	ss = ss*(ss>0.0f);	dst[index] = (s==0.0f)?t:t*ss/s;}////////////////////////////////////////////////////////////////////////////////////////////////////void shrink1(	float2* src,	float2* dst,	int dimx,			int dimy,			int dimz,	float Lambda){	dim3 numBlocks(		(dimx/blockDimx + ((dimx%blockDimx)?1:0)),		(dimy/blockDimy + ((dimy%blockDimy)?1:0)),		(dimz/blockDimz + ((dimz%blockDimz)?1:0)) );	dim3 numThreads(blockDimx, blockDimy, blockDimz);	__shrink1<<<numBlocks, numThreads>>>(src, dst, dimx, dimy, dimz, Lambda);}////////////////////////////////////////////////////////////////////////////////////////////////////__global__void __shrink2(	float2* srcA, 		float2* srcB,		float2* dstA,		float2* dstB,	int dimx,			int dimy,			int dimz,	float Lambda){	//3D global index	int3 idx = make_int3(		blockIdx.x*blockDim.x+threadIdx.x,		blockIdx.y*blockDim.y+threadIdx.y,		blockIdx.z*blockDim.z+threadIdx.z);		//1D global index	int index 	= 	idx.z*dimy*dimx						+	idx.y*dimx								+	idx.x;													  	//Check valid indices	if (idx.x >= dimx || idx.y >= dimy || idx.z >= dimz)		return;		//Do computing	float2 a = srcA[index];	float2 b = srcB[index];		float s  = sqrtf(a.x*a.x + a.y*a.y + b.x*b.x +b.y*b.y);	float ss = s - Lambda;	ss = ss*(ss>0.0f);		dstA[index] = (s==0.0f)?a:a*ss/s;	dstB[index] = (s==0.0f)?b:b*ss/s;}////////////////////////////////////////////////////////////////////////////////////////////////////void shrink2(	float2* srcA, 	float2* srcB,		float2* dstA,	float2* dstB,		int dimx,			int dimy,			int dimz,	float Lambda){	dim3 numBlocks(		(dimx/blockDimx + ((dimx%blockDimx)?1:0)),		(dimy/blockDimy + ((dimy%blockDimy)?1:0)),		(dimz/blockDimz + ((dimz%blockDimz)?1:0)) );	dim3 numThreads(blockDimx, blockDimy, blockDimz);	__shrink2<<<numBlocks, numThreads>>>(srcA, srcB, dstA, dstB, dimx, dimy, dimz, Lambda);}////////////////////////////////////////////////////////////////////////////////////////////////////}